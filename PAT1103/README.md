# 解题思路

## 存储表+DP/DFS
====================
* 利用二维存储表存储当前正整数N和因子fac所对应的剩余值*rem=N-fac^P*
* 因此这张存储表构成了多颗树，树的根为第N列的1~N^(1/P)，每一列值代表树节点
* 通过DFS遍历每颗树，即可得到解
* 每一级因子从大到小排列，防止出现多个相同解只是排列不同，并且省去不必要的遍历，且满足题目输出要求
* 为了防止超时，需要三项操作：剪枝、从大到小遍历、当前最大因子和解存储（DP）、最大因子预存

## 防止超时三项操作
====================
* 剪枝：
     * 对于因子数不够K但是幂和大于等于N的分支剪掉
     * 对于因子和达到K但是幂和小于N的分支剪掉
     * 对于当前因子大于前一级因子的情况下可以直接剪枝，以保证每一级因子从大到小排列
     * 对于出现解的分支，可将小于当前最后一个因子的分支剪掉并返回上一级，因为它们的幂和肯定小于N

* 从大到小遍历：
     * 针对剪枝的第三项操作而提出。若当前分支的幂和等于或小于N，那么接下来同级且小于当前因子的分支幂和必定小于N，可以不必去遍历

* 当前最大因子和解存储：
     * 由于最终解不唯一，但是题目只要求最大因子和且字典序最大的的解。通常做法是对所有解进行存储并排序，然后输出题目要求的解，但是这样做会使得时间复杂度和空间复杂度大大提升
     * 根据DP的思路，我们可以实时存储当前因子和最大字典序的解，由于从大到小的遍历做法给了我们更简单的实现方案，且时空间复杂度为*O(1)*
     * 从大到小的遍历可以保证当前满足幂和为N的解在因子和最大的情况下字典序最大，通过比较当前解与之前局部最优解的因子和大小，可以做出替换选择；如果它们的因子和相等，则不替换，因为之前局部最优解的字典序较大

* 最大因子预存：
     * 开一张表预存每个N下的最大因子facMax，该因子facMax在满足*facMax^P<=N*情况下最大
     * 这样可以在遍历时，直接定位最大因子值而不必重新从sqrt(N)开始遍历，相当于剪枝
      
## 最后由于cmath自带的pow函数较慢，可以自己实现
=====================
* cmath自带的pow函数时间复杂度与指数呈线性关系
* 自己去实现一个与指数呈对数关系时间复杂度的myPow函数
      
